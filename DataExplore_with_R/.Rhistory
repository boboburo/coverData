& index<=3){
MPN<-zurdata[Masked.Personnel.Number %in% MPN_1Year & Year==theYear & is.na(Function),Masked.Personnel.Number]
baseYear<-theYear
change<-incYears[index,get(refYear)]
zurQuery<-zurdata[Year==(baseYear+change) & !is.na(Function) & Masked.Personnel.Number %in% MPN,.(Masked.Personnel.Number, Function,Sub.Function)]
zurQuery[,Year:=as.character(baseYear)]
setkey(zurQuery,Masked.Personnel.Number,Year)
#Insert the imputed values and keep record of imputes.
zurdata<-zurdata[zurQuery, Function := i.Function, nomatch=0]
zurdata<-zurdata[zurQuery, Sub.Function := i.Sub.Function, nomatch=0]
zurdata<-zurdata[zurQuery, cImp2 := paste0("Y",(baseYear+change)), nomatch=0]
index=index+1
}#End of while loop, looping through each adjacent year, 3 times or until there are no nas.
}#End of for loop for looping through each year
rm(Years,y2012,y2013,y2014,y2015,incYears,theYear,baseYear,change,zurQuery,refYear)
rm(MPN,MPN_1Year)
MPN<-unique(zurdata[is.na(Function),Masked.Personnel.Number])
MPN_1Year<- unique(zurdata[Masked.Personnel.Number %in% MPN & !is.na(Function),Masked.Personnel.Number])
MPN_0Year<-setdiff(MPN,MPN_1Year)
y2012<-c(1,2,3)
y2013<-c(1,-1,2)
y2014<-c(1,-1,-2)
y2015<-c(-1,-2,-3)
incYears<-data.table(y2012,y2013,y2014,y2015)
setkey(zurdata,Masked.Personnel.Number,Year)
for(theYear in  Years){
refYear<-paste0("y",theYear)
index<-1
while(sum(is.na(zurdata[Year==theYear & Masked.Personnel.Number %in% MPN_1Year,Function]))>0
& index<=3){
MPN<-zurdata[Masked.Personnel.Number %in% MPN_1Year & Year==theYear & is.na(Function),Masked.Personnel.Number]
baseYear<-theYear
change<-incYears[index,get(refYear)]
zurQuery<-zurdata[Year==(baseYear+change) & !is.na(Function) & Masked.Personnel.Number %in% MPN,.(Masked.Personnel.Number, Function,Sub.Function)]
zurQuery[,Year:=as.character(baseYear)]
setkey(zurQuery,Masked.Personnel.Number,Year)
#Insert the imputed values and keep record of imputes.
zurdata<-zurdata[zurQuery, Function := i.Function, nomatch=0]
zurdata<-zurdata[zurQuery, Sub.Function := i.Sub.Function, nomatch=0]
zurdata<-zurdata[zurQuery, cImp2 := paste0("Y",(baseYear+change)), nomatch=0]
index=index+1
}#End of while loop, looping through each adjacent year, 3 times or until there are no nas.
}#End of for loop for looping through each year
Years<-c(2012,2013,2014,2015)
#Index to search before and after based on each year
y2012<-c(1,2,3)
y2013<-c(1,-1,2)
y2014<-c(1,-1,-2)
y2015<-c(-1,-2,-3)
incYears<-data.table(y2012,y2013,y2014,y2015)
setkey(zurdata,Masked.Personnel.Number,Year)
for(theYear in  Years){
refYear<-paste0("y",theYear)
index<-1
while(sum(is.na(zurdata[Year==theYear & Masked.Personnel.Number %in% MPN_1Year,Function]))>0
& index<=3){
MPN<-zurdata[Masked.Personnel.Number %in% MPN_1Year & Year==theYear & is.na(Function),Masked.Personnel.Number]
baseYear<-theYear
change<-incYears[index,get(refYear)]
zurQuery<-zurdata[Year==(baseYear+change) & !is.na(Function) & Masked.Personnel.Number %in% MPN,.(Masked.Personnel.Number, Function,Sub.Function)]
zurQuery[,Year:=as.character(baseYear)]
setkey(zurQuery,Masked.Personnel.Number,Year)
#Insert the imputed values and keep record of imputes.
zurdata<-zurdata[zurQuery, Function := i.Function, nomatch=0]
zurdata<-zurdata[zurQuery, Sub.Function := i.Sub.Function, nomatch=0]
zurdata<-zurdata[zurQuery, cImp2 := paste0("Y",(baseYear+change)), nomatch=0]
index=index+1
}#End of while loop, looping through each adjacent year, 3 times or until there are no nas.
}#End of for loop for looping through each year
sum(is.na(zurdata$Function))
load(thefile)
sum(is.na(zurdata$Function))
table(zurdata[Function == "Procurement" | Function == "Sourcing",.(Function,Year)])
zurdata<-zurdata[(Function == "Procurement"| Function == "Sourcing"),Function := "Sourcings" ]
table(zurdata[Function == "Sourcings" ,.(Function,Year)])
zurdata<-zurdata[(Function == "Procurement"| Function == "Sourcings"),Function := "Sourcing" ]
table(zurdata[Function == "Sourcing" ,.(Function,Year)])
table(zurdata[Function == "Corporate Real Estate and Facility Mgmt."| Function == "Corporate Real Estate & Facilities Mgmt.",.(Function,Year)])
zurdata<-zurdata[Function=="Corporate Real Estate and Facility Mgmt.",Function := "Corporate Real Estate & Facilities Mgmt."]
table(zurdata[Function == "Corporate Real Estate & Facilities Mgmt.",.(Function,Year)])
sum(is.na(zurdata$Function))
#Clean up others not one to one mapping.
MPN<-unique(zurdata[Sub.Function == "Strat. Corp. Real Estate&Facility Mgmt.",Masked.Personnel.Number])
modeReplace1<-zurdata[Masked.Personnel.Number %in% MPN,] %>% group_by(Function,Masked.Personnel.Number) %>% summarise(sFunc = names(which.max(table(Sub.Function))),count=.N)
#Record 34 changes Function.
modeReplace1<-modeReplace1[Function=="Corporate Real Estate & Facilities Mgmt.",]
#Clean up others not one to one mapping.
MPN<-unique(zurdata[Sub.Function == "Corp. Real Estate & Facility Mgmt. Ops.",Masked.Personnel.Number])
modeReplace2<-zurdata[Masked.Personnel.Number %in% MPN,] %>% group_by(Function,Masked.Personnel.Number) %>% summarise(sFunc = names(which.max(table(Sub.Function))),count=.N)
#Record 34 changes Function.
modeReplace2<-modeReplace2[Function=="Corporate Real Estate & Facilities Mgmt.",]
#Change the value of *Sub.Function*
zurdata<-zurdata[Sub.Function=="N/A Sub-Function",Sub.Function := "No Sub-Functions (Sourcing)"]
#Check and change Sub.Function of Function "Corporate Real Estate & Facilities Mgmt."
sum(table(zurdata[Function == "Corporate Real Estate & Facilities Mgmt.",(Sub.Function)]))
table(zurdata[Function == "Corporate Real Estate & Facilities Mgmt.",.(Sub.Function)])
zurdata<-zurdata[Sub.Function=="Facility Management",Sub.Function := "Facilities Management"]
zurdata<-zurdata[Sub.Function=="Document Management",Sub.Function := "Document Logistics"]
#Use a data.table query to set the new values for the Sub.Funcitons = (Strat. Corp. Real Estate & Facility Mgmt. OR Corp. Real Estate & Facility Mgmt. Ops.)
modeReplace1[,Year:=as.character(2012)]
modeReplace2[,Year:=as.character(2012)]
setkey(zurdata,Masked.Personnel.Number,Year)
setkey(modeReplace1,Masked.Personnel.Number,Year)
setkey(modeReplace2,Masked.Personnel.Number,Year)
zurdata<-zurdata[modeReplace1, Sub.Function := sFunc, nomatch=0] #Strat. Corp. Real Estate&Facility Mgmt.
zurdata<-zurdata[modeReplace2, Sub.Function := sFunc, nomatch=0] #Corp. Real Estate & Facility Mgmt. Ops.
rm(modeReplace1,modeReplace2)
#There is one row with value for Function but none for Sub.Function.
zurdata[!(is.na(Function)) & is.na(Sub.Function),Sub.Function := "No Sub-Functions (UW)"]
MPN<-unique(zurdata[is.na(Function),Masked.Personnel.Number])
MPN_1Year<- unique(zurdata[Masked.Personnel.Number %in% MPN & !is.na(Function),Masked.Personnel.Number])
MPN_0Year<-setdiff(MPN,MPN_1Year)
sum(is.na(zurdata$Function))
Whole population
tempTable<-table(statusPath[,.(sFinal)])
propTable<-(tempTable/sum(tempTable))
#Transpose and move to data frame and add last row of proportions
myrow<-data.frame(t(tempTable[1:2]))
myrow<-cbind(myrow,data.frame(t(round(propTable[1:2],2))))
mytable<-rbind(myrow)
#MPNs with no missing values.
tempTable<-table(statusPath[!Masked.Personnel.Number %in% MPN,.(sFinal)])
propTable<-(tempTable/sum(tempTable))
#Transpose and move to data frame and add last row of proportions
myrow<-data.frame(t(tempTable[1:2]))
myrow<-cbind(myrow,data.frame(t(round(propTable[1:2],2))))
mytable<-rbind(mytable,myrow)
#MPNs with at least one value.
tempTable<-table(statusPath[Masked.Personnel.Number %in% MPN_1Year,.(sFinal)])
propTable<-(tempTable/sum(tempTable))
#Transpose and move to data frame and add last row of proportions
myrow<-data.frame(t(tempTable[1:2]))
myrow<-cbind(myrow,data.frame(t(round(propTable[1:2],2))))
mytable<-rbind(mytable,myrow)
#MPNs with at all missing
tempTable<-table(statusPath[Masked.Personnel.Number %in% MPN_0Year,.(sFinal)])
propTable<-(tempTable/sum(tempTable))
#Transpose and move to data frame and add last row of proportions
myrow<-data.frame(t(tempTable[1:2]))
myrow<-cbind(myrow,data.frame(t(round(propTable[1:2],2))))
mytable<-rbind(mytable,myrow)
row.names(mytable)<-c("Total Pop.","No missing values in Function","Mix blank/non-blank Function","All blank Function")
rm(propTable,tempTable,mSegChange)
pandoc.table(mytable,caption="Breakdown of Employment.Status for MPNs with missing values in Function", caption.prefix="Table:",split.table=Inf,justify=c("left"))
Years<-c(2012,2013,2014,2015)
#Index to search before and after based on each year
y2012<-c(1,2,3)
y2013<-c(1,-1,2)
y2014<-c(1,-1,-2)
y2015<-c(-1,-2,-3)
incYears<-data.table(y2012,y2013,y2014,y2015)
setkey(zurdata,Masked.Personnel.Number,Year)
for(theYear in  Years){
refYear<-paste0("y",theYear)
index<-1
while(sum(is.na(zurdata[Year==theYear & Masked.Personnel.Number %in% MPN_1Year,Function]))>0
& index<=3){
MPN<-zurdata[Masked.Personnel.Number %in% MPN_1Year & Year==theYear & is.na(Function),Masked.Personnel.Number]
baseYear<-theYear
change<-incYears[index,get(refYear)]
zurQuery<-zurdata[Year==(baseYear+change) & !is.na(Function) & Masked.Personnel.Number %in% MPN,.(Masked.Personnel.Number, Function,Sub.Function)]
zurQuery[,Year:=as.character(baseYear)]
setkey(zurQuery,Masked.Personnel.Number,Year)
#Insert the imputed values and keep record of imputes.
zurdata<-zurdata[zurQuery, Function := i.Function, nomatch=0]
zurdata<-zurdata[zurQuery, Sub.Function := i.Sub.Function, nomatch=0]
zurdata<-zurdata[zurQuery, cImp2 := paste0("Y",(baseYear+change)), nomatch=0]
index=index+1
}#End of while loop, looping through each adjacent year, 3 times or until there are no nas.
}#End of for loop for looping through each year
rm(Years,y2012,y2013,y2014,y2015,incYears,theYear,baseYear,change,zurQuery,refYear)
rm(MPN,MPN_1Year)
MPN<-unique(zurdata[is.na(Function),Masked.Personnel.Number])
zurdata[is.na(Function),.(Function,Sub.FUnction):="Not Recorded"]
z_byMPN<-dplyr::group_by(zurdata,Masked.Personnel.Number)
#############GENERATE Num Unque changes since 2012 (Slow)#################
z_lastSalaries = dplyr::summarise(z_byMPN,Annual.Salary.0.USD=tail(Annual.Salary.0.USD,1),Annual.Salary.1.USD=tail(Annual.Salary.1.USD,1),Annual.Salary.2.USD=tail(Annual.Salary.2.USD,1),Annual.Salary.3.USD=tail(Annual.Salary.3.USD,1),Annual.Salary.4.USD=tail(Annual.Salary.4.USD,1))
head(z_lastSalaries)
zurdata[Masked.Personnel.Number=="R74000001",.(Year,Annual.Salary.0.USD)]
zurdata[Masked.Personnel.Number=="R74000003",.(Year,Annual.Salary.0.USD)]
d = data.frame(z_lastSalaries$Annual.Salary.0.USD_Change,z_lastSalaries$Annual.Salary.1.USD_Change,z_lastSalaries$Annual.Salary.2.USD_Change,z_lastSalaries$Annual.Salary.3.USD_Change)
head(d)
z_lastSalaries$Annual.Salary.0.USD_Change =  (z_lastSalaries$Annual.Salary.0.USD-z_lastSalaries$Annual.Salary.1.USD)/z_lastSalaries$Annual.Salary.1.USD
z_lastSalaries$Annual.Salary.1.USD_Change =  (z_lastSalaries$Annual.Salary.1.USD-z_lastSalaries$Annual.Salary.2.USD)/z_lastSalaries$Annual.Salary.2.USD
z_lastSalaries$Annual.Salary.2.USD_Change =  (z_lastSalaries$Annual.Salary.2.USD-z_lastSalaries$Annual.Salary.3.USD)/z_lastSalaries$Annual.Salary.3.USD
z_lastSalaries$Annual.Salary.3.USD_Change =  (z_lastSalaries$Annual.Salary.3.USD-z_lastSalaries$Annual.Salary.4.USD)/z_lastSalaries$Annual.Salary.4.USD
#Get Max Positive and Negative Salary Change
d = data.frame(z_lastSalaries$Annual.Salary.0.USD_Change,z_lastSalaries$Annual.Salary.1.USD_Change,z_lastSalaries$Annual.Salary.2.USD_Change,z_lastSalaries$Annual.Salary.3.USD_Change)
head(d)
version
library(devtools)
library(data.table)
install.packages("devtools")
R_LIBS=c:/myRlib
library(data.table)
DT1 <- as.data.table(matrix(c(0, 1, 2, 3), nrow=2, ncol=2,
dimnames=list(c("a", "b"), c("a", "b"))), keep=T)
DT2 <- as.data.table(matrix(c(0, 0, 1, 2, 2, 1, 1, 0, 3), nrow=3, ncol=3,
dimnames=list(c("a", "b", "c"), c("a", "b", "c"))), keep=T)
DT1
DT2
xcols = c("a", "b")
icols = paste0("i.", xcols) # "i.*" to refer to DT1's cols
icols
DT2[DT1, (xcols) := Map(function(x, y) x + (y > 0L), mget(xcols), mget(icols)), on="rn"]
DT23
DT2
mget(xcols)
DT1 <- as.data.table(matrix(c(0, 1, 2, 3), nrow=2, ncol=2,
dimnames=list(c("a", "b"), c("a", "b"))), keep=T)
DT2 <- as.data.table(matrix(c(0, 0, 1, 2, 2, 1, 1, 0, 3), nrow=3, ncol=3,
dimnames=list(c("a", "b", "c"), c("a", "b", "c"))), keep=T)
DT1
DT3
DT2
keycols<-("a","b")
keycols<-c("a","b")
setkey(DT1,keycols)
setkey(DT2,keycols)
keycols<-c("a","b")
setkey(DT1,keycols)
DT1 <- as.data.table(matrix(c(0, 1, 2, 3), nrow=2, ncol=2,
dimnames=list(c("a", "b"), c("a", "b"))), keep=T)
DT2 <- as.data.table(matrix(c(0, 0, 1, 2, 2, 1, 1, 0, 3), nrow=3, ncol=3,
dimnames=list(c("a", "b", "c"), c("a", "b", "c"))), keep=T)
DT1
setkey(DT1,keycols)
keycols = c("a","b")
setkey(DT1,keycols)
class(DT1)
names(DT1)
setkey(DT1,keycols)
setkey(DT1,"a")
setkey(DT1,c("a","b"))
setkeys(DT1,c("a","b"))
setkeyv(DT1,c("a","b"))
setkeyv(DT2,keycols)
DT1[DT2,]
DT1 <- as.data.table(matrix(c(0, 1, 2, 3), nrow=2, ncol=2,
dimnames=list(c("a", "b"), c("a", "b"))), keep=T)
DT2 <- as.data.table(matrix(c(0, 0, 1, 2, 2, 1, 1, 0, 3), nrow=3, ncol=3,
dimnames=list(c("a", "b", "c"), c("a", "b", "c"))), keep=T)
keycols <- c("a","b")
setkeyv(DT1,keycols))
setkeyv(DT2,keycols)
DT1[DT2,]
keycols <- c("a","b")
setkeyv(DT1,keycols))
setkeyv(DT1,keycols)
setkeyv(DT2,keycols)
DT1[DT2,]
DT1[DT2,,with=F]
DT1[DT2,,with=T]
DT1
DT2
DT2[DT1,]
DT1
DT2
DT2[DT1,,with=F]
DT2[DT1,,with=T]
DT1
DT2
keycols <- c("rn","a","b")
setkeyv(DT1,keycols)
setkeyv(DT2,keycols)
DT2[DT1,,with=T]
library(data.table)
DT2[DT1,]
panderOptions(split.table=Inf)
#Set some global options for r chunks. Want R chunk to evaluate, but not included for client facing document.
knitr::opts_chunk$set(cache=TRUE,cache.lazy = TRUE,
fig.height=4,fig.width=6,fig.align='center',fig.path='figure/',
warning=FALSE,message=FALSE,error=FALSE,echo=FALSE
)  ##background doesn't work
#Caching gives some funny results but it can result in faster loading times, when writing up the document. This is to do with the := assignment in data.table. Knitr doesn't recognise, therefore always use <-
#Libraries required
#Data work
require(data.table) #Working with large files
require(xlsx)       #Loading and saving .xlsx files
require(plyr)   #Always load in this order plyr, dpply, lubridate - dpplyr overrides some of methods in plyr.
require(dplyr) #Use require as it will give an error message if the package doesn't exist
require(lubridate) #used for working with data information.
require(reshape2)  #used for melting
#Formating and printing
#install.packages("devtools")
#devtools::install_github("adletaw/captioner")   #Nice library for numbering and captioning tables in conjunction with knitr and pandoc
require(pander)   	#for creating nice output tables.
require(captioner)
#Set up the figure and table numbering
fig_nums<-captioner()
tab_nums<-captioner(prefix = "Table")
#Using pryr abbreviate how to call fig_nums function
require(pryr)
citefig<-pryr::partial(fig_nums,display="cite")
citetab<-pryr::partial(tab_nums,display="cite")
#Turn off caption. prefix as allow captioner to handle this.
panderOptions('table.caption.prefix', '')
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)
panderOptions(split.table=Inf)
panderOptions(justify=c("left"))
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\Client_Data\\01_Zurich\\Data Processes\\Data Explore R\\Round2\\Data\\Watson_data file_bc.csv"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
zurdata<-data.table::fread(theFile,header=TRUE,na.strings=c(""))
#summaryTable to gather statistics.
summaryTable<-data.table(originalNames=names(zurdata))
#Fix up some of the names of the zurdata that have spaces or lead with numericals. This is not a problem within a data.table type
#however causes problems outside of data.table where R variables can not start with numericals and data.frame (not data_frame)
#automatically introduces . for spaces.
zurColNames<-names(zurdata)
zurColNames<-gsub('\\s+','.',zurColNames)
setnames(zurdata, zurColNames )
rm(zurColNames)
#Change the names of 3 columns starting with numbers. Can cause problems with R interpreter or many other programs such as Excel. Other columns contain % / ( These are changed
setnames(zurdata,c('9boxgrid.2014','9boxgrid.2013','9boxgrid.2012'),c('n9boxgrid.2014','n9boxgrid.2013','n9boxgrid.2012'))
setnames(zurdata,c("Voluntary./.Involuntary","STIP.Target.%","STIP.FT/PT.%", "STIP.Ansal.USD.(100%)","STIP.Trgt.Amt.USD.(prorated)", "STIP.Final.%"),c("Vol_Invol","STIP.Target.Pr","STIP.FTPT.Pr","STIP.Ansal.USD.110PR","STIP.Trgt.Amt.USD.prorated","STIP.Final.Pr"))
summaryTable[,newNames:=names(zurdata)]   #doesn't update in the Environment. Bug in RStudio and data.table
summaryTable[,columnClass:= sapply(zurdata,class)]
#####NOT THIS WAY, much quicker to use lapply and transpose######
#summaryTable[,missing:=  apply(zurdata, 2, function(x) length(which(is.na(x))))]  #there is a quicker way of this.
#summaryTable[,levels:=  apply(zurdata, 2, function(x) length(unique((x))))]
#######################
summaryTable[,missing := t(zurdata[,lapply(.SD,function(x) length(which(is.na(x))))]),]
summaryTable[,levels :=  t(zurdata[,lapply(.SD,function(x) length(unique(x)))]),]
mytable<-data.frame(summaryTable)
mytable<-mytable[,c(1,2,4,5)]
tab_nums("colNames","Column Names Alteration")
pandoc.table(mytable,caption=tab_nums("colNamesTable"),split.table=Inf,justify=c("left"))
pandoc.table(mytable,caption=tab_nums("colNames"),split.table=Inf,justify=c("left"))
citetab("sumTable")
#Determine if column is numeric. Extract list of column names.
numeric.index<-names(which(sapply(zurdata,is.numeric)))
#The inner data.table returns a list of values with NULL for non.numeric.
summaryTableM<-summaryTable[newNames %in% numeric.index,zmin:=zurdata[,lapply(.SD,min,na.rm=T),,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zsecondQ:=zurdata[,lapply(.SD,quantile,na.rm=T)[2],,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zmedian:=zurdata[,lapply(.SD,median,na.rm=T),,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zthirdQ:=zurdata[,lapply(.SD,quantile,na.rm=T)[4],,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zmax:=zurdata[,lapply(.SD,max,na.rm=T),,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zmean:=zurdata[,lapply(.SD,mean,na.rm=T),,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zsd:=zurdata[,lapply(.SD,sd,na.rm=T),,.SDcols=numeric.index]]
summaryTableM<-summaryTable[newNames %in% numeric.index,zmad:=zurdata[,lapply(.SD,mad,na.rm=T),,.SDcols=numeric.index]]
#Round the new variables and set the NULLS to NA. NULLs are result of calculation methods above.
is.na(summaryTable) <- summaryTable == "NULL"
roundCols <- c("zmin","zsecondQ","zmedian","zthirdQ","zmax","zmean","zsd","zmad")
summaryTable<-summaryTable[,(roundCols):=lapply(.SD,function(x) round(unlist(x),2)),.SDcols=roundCols]
rm(roundCols)
categorical.index<-summaryTable[(levels<70000 & columnClass=="character"),newNames]
categorical.index2<-summaryTable[(levels>=70000 & columnClass=="character"),newNames]
for(i in categorical.index[1:34]){
charColumn<-i
freqOfCol<-data.frame(zurdata[, list(Count=.N) ,by = charColumn][order(-Count)])
write.xlsx(x = freqOfCol, file = "zurDataCategorical_Levels1.xlsx",
sheetName = charColumn, row.names = FALSE,append=TRUE)
}
#Excel runs out of memory, need to split.
#Loop through each column in the original data.table "zurdata"
for(i in categorical.index[35:55]){
charColumn<-i
freqOfCol<-data.frame(zurdata[, list(Count=.N) ,by = charColumn][order(-Count)])
write.xlsx(x = freqOfCol, file = "zurDataCategorical_Levels.xlsx",
sheetName = charColumn, row.names = FALSE,append=TRUE)
}
mytable<-zurdata[Masked.Personnel.Number=="R74055062",.(Year,Masked.Personnel.Number,STIP.Target.Pr,STIP.FTPT.Pr,STIP.PM.Rating)]
tab_nums("remove062","Removal of Employee Record")
pandoc.table(mytable,caption=tab_nums("remove062"),split.table=Inf,justify=c("left"))
Herzberg Data Analysis
a<-c("Brian","colin")
library(tau)
install.packages("tau")
library(tau)
library(tau)
txt <- "The quick brown fox jumps over the lazy dog."
textcnt(txt, method = "ngram")
textcnt(a,method="ngram")
textcnt(txt, method = "ngram",n=3)
textcnt(txt, method = "ngram",n=3L)
library(devtools)
install_github("MangoTheCat/tidyshiny")
install.packages("curl")
install_github("MangoTheCat/tidyshiny")
tidyshiny:::tidyData()
testData<airquality
testData<-airquality
tidyshiny:::tidyData()
tidyshiny:::tidyData()
tidyshiny:::tidyData()
tidyshiny:::tidyData()
cid <-c("AFG")*10
cid <-rep("AFG",10)
time <- seq(20,29,1)
data<-as.data.frame(cid,time,event)
event <- c(0,0,0,0,0,0,1,1,1,1)
data<-as.data.frame(cid,time,event)
data
df<-as.data.frame(cid,time,event)
df<-as.data.frame(cid,time)
df<-as.data.frame(cid)
df<-as.data.frame(cid,event)
df<-as.data.frame(time)
df<-as.data.frame(event)
df<-as.data.frame(cid=cid,time=time,event=event)
data<-do.call(rbind, Map(data.frame,cid,time,event)
)
data<-data.frame(cid=rep("AFG",10),time=seq(20,29,l),event=c(0,0,0,0,0,0,1,1,1,1))
data<-data.frame(cid=rep("AFG",10),time=seq(20,29,1),event=c(0,0,0,0,0,0,1,1,1,1))
data
library(dplyr)
dataSummary<-data %>% group_by(cid,event) %>%
summarise(cid=cid,time1=min(time),time2=max(time2),event=event)
data %>% group_by(cid,event) %>%
summarise(cid=cid,time1=min(time),time2=max(time2),event=event)
data %>% group_by(event) %>%
summarise(cid=cid,time1=min(time),time2=max(time2),event=event)
data<-data.frame(cid=rep("AFG",10),time=seq(20,29,1),event=c(0,0,0,0,0,0,1,1,1,1))
library(dplyr)
data %>% group_by(event) %>%
summarise(cid=cid,time1=min(time),time2=max(time2),event=event)
dta
data
data %>% group_by("event") %>%
summarise(cid=cid,time1=min(time),time2=max(time2),event=event)
data %>% group_by("event") %>%
summarise(time1=min(time))
data %>% group_by(event) %>%
summarise(time1=min(time))
data %>% group_by(cid,event) %>%
summarise(time1=min(time))
data %>% group_by(cid,event) %>%
summarise(time1=min(time),time2=max(time))
ut <- data.frame(AnnoNascita=c(1926,1971,1930,1947,Regione=c(16,16,16,21,15)))
ut
ut <- data.frame(AnnoNascita=c(1926,1971,1930,1947),Regione=c(16,16,16,21,15)))
ut <- data.frame(AnnoNascita=c(1926,1971,1930,1947),Regione=c(16,16,16,21,15))
ut <- data.frame(AnnoNascita=c(1926,1971,1930,1947),Regione=c(16,16,16,21))
ut
ut$eta = 2016-ut$AnnoNascita
ut
install.packages("GGally")
setwd("C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\DataExplore_with_R")
setwd("C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\DataExplore_with_R")
#Set some global options for r chunks.
knitr::opts_chunk$set(cache=FALSE,cache.lazy = FALSE,
fig.path='figure/',
warning=FALSE,message=FALSE,error=FALSE,echo=FALSE,fig.width = 12, fig.align = 'center',fig.height=8
)  ##background doesn't work
#Caching gives some funny results but it can result in faster loading times, when writing up the document. This is to do with the := assignment in data.table. Knitr doesn't recognise, therefore always use <-
##Libraries required
#Data work
require(data.table) #Working with large files
require(xlsx)       #Loading and saving .xlsx files
require(plyr)   #Always load in this order plyr, dpply, lubridate - dpplyr overrides some of methods in plyr.
require(dplyr) #Use require as it will give an error message if the package doesn't exist
require(lubridate) #used for working with data information.
require(reshape2)  #used for melting
require(ggplot2)
#install.packages("ggthemes")
require(ggthemes)
require(scales)
require(GGally)
#require(cowplot)
require(gridExtra)
#Formating and printing
#install.packages("devtools")
#devtools::install_github("adletaw/captioner")   #Nice library for numbering and captioning tables in conjunction with knitr and pandoc
require(pander)   	#for creating nice output tables.
require(captioner)
#Set up the figure and table numbering
fig_nums<-captioner(prefix = "Figure")
tab_nums<-captioner(prefix = "Table")
#Using pryr abbreviate how to call fig_nums function
require(pryr)
citefig<-pryr::partial(fig_nums,display="cite")
citetab<-pryr::partial(tab_nums,display="cite")
#Turn off caption.prefix as allow captioner to handle this.
panderOptions('table.caption.prefix', '')
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('keep.line.breaks',TRUE)
panderOptions('table.emphasize.rownames',TRUE)
#Create theme for ggplots
theme_adMobile <- function(){
theme(
axis.text.x=element_text(angle=30,hjust=1,size=12),
axis.text.y=element_text(size=12),
axis.title.x=element_text(size=14),
axis.title.y=element_text(size=14),
panel.background = element_blank(),
title=element_text(size=16))
}
##File for the data file.
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\data\\coytype.data"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
coverData<-data.table::fread(theFile,header=FALSE,na.strings=c(""))
##File for the data file.
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\data\\covtype.data"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
coverData<-data.table::fread(theFile,header=FALSE,na.strings=c(""))
##File for the data file.
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\data\\covtype"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
coverData<-data.table::fread(theFile,header=FALSE,na.strings=c(""))
#"C:\Users\IBM_ADMIN\Desktop\github\coverData\data\covtype.data"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
coverData<-data.table::fread(theFile,header=FALSE,na.strings=c(""))
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\data\\covtype.data"
#"C:\Users\IBM_ADMIN\Desktop\github\coverData\data\covtype.data"
#Read in the file, try to use the syntax as applied here to keep track of what packages do what.
coverData<-data.table::fread(theFile,header=FALSE,na.strings=c(""))
theFile="C:\\Users\\IBM_ADMIN\\Desktop\\github\\coverData\\metadata.xlsx"
colNames<-data.table(read.xlsx(theFile, sheetName = "colNames"))
coverData<-setnames(coverData, as.character(colNames[,dbName]) )
View(coverData)
